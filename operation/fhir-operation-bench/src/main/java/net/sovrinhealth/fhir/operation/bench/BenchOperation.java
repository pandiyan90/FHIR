/*
 * (C) Copyright IBM Corp. 2022
 *
 * SPDX-License-Identifier: Apache-2.0
 */

package net.sovrinhealth.fhir.operation.bench;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

import net.sovrinhealth.fhir.exception.FHIROperationException;
import net.sovrinhealth.fhir.model.format.Format;
import net.sovrinhealth.fhir.model.generator.FHIRGenerator;
import net.sovrinhealth.fhir.model.parser.FHIRParser;
import net.sovrinhealth.fhir.model.resource.OperationDefinition;
import net.sovrinhealth.fhir.model.resource.OperationOutcome;
import net.sovrinhealth.fhir.model.resource.OperationOutcome.Issue;
import net.sovrinhealth.fhir.model.resource.Parameters;
import net.sovrinhealth.fhir.model.resource.Resource;
import net.sovrinhealth.fhir.model.type.code.IssueSeverity;
import net.sovrinhealth.fhir.model.type.code.IssueType;
import net.sovrinhealth.fhir.model.visitor.ResourceFingerprintVisitor;
import net.sovrinhealth.fhir.persistence.util.InputOutputByteStream;
import net.sovrinhealth.fhir.search.util.SearchHelper;
import net.sovrinhealth.fhir.server.spi.operation.AbstractOperation;
import net.sovrinhealth.fhir.server.spi.operation.FHIROperationContext;
import net.sovrinhealth.fhir.server.spi.operation.FHIROperationUtil;
import net.sovrinhealth.fhir.server.spi.operation.FHIRResourceHelpers;

/**
 * Custom operation to consume some CPU load to help out with
 * understanding the relative performance of systems. This is
 * particularly useful deploying in a cloud environment like
 * K8s where the worker nodes are virtual, so you don't really
 * know how much capacity a vCPU actually gives you.
 * 
 * The operation has 2 parameters:
 *   threads - how many threads to spin up
 *   size - how much "work" to perform
 */
public class BenchOperation extends AbstractOperation {
    private static final Logger logger = Logger.getLogger(BenchOperation.class.getName());

    private static final String PARAM_THREADS = "threads";
    private static final String PARAM_SIZE = "size";

    // A reasonably large example resource generated by synthea
    private static final String EXAMPLE_RESOURCE = "data/Ada_Daugherty_1fef6a08-a35c-53c0-eb1a-48c54e7bb33f.json";
    private static final int DATA_BUFFER_INITIAL_SIZE = 4096;

    public BenchOperation() {
        super();
    }

    @Override
    protected OperationDefinition buildOperationDefinition() {
        try (InputStream in = getClass().getClassLoader().getResourceAsStream("bench.json")) {
            return FHIRParser.parser(Format.JSON).parse(in);
        } catch (Exception e) {
            throw new Error(e);
        }
    }

    @Override
    protected boolean isAbstractResourceTypesDisallowed() {
        return true;
    }

    @Override
    protected Parameters doInvoke(FHIROperationContext operationContext, Class<? extends Resource> resourceType,
            String logicalId, String versionId, Parameters parameters, FHIRResourceHelpers resourceHelper, SearchHelper searchHelper)
            throws FHIROperationException {

        try {
            int threads = 1;
            int size = 1;

            List<Issue> issues = new ArrayList<>();
            if (parameters != null) {
                for (Parameters.Parameter parameter : parameters.getParameter()) {
                    if (parameter.getValue() != null && logger.isLoggable(Level.FINE)) {
                        logger.fine("bench param: " + parameter.getName().getValue() + " = " + parameter.getValue().toString());
                    }

                    if (PARAM_THREADS.equals(parameter.getName().getValue())) {
                        Integer val = parameter.getValue().as(net.sovrinhealth.fhir.model.type.Integer.class).getValue();
                        if (val != null) {
                            threads = val;
                        }

                        if (threads < 1 || threads > 64) {
                            issues.add(Issue.builder()
                                .code(IssueType.BUSINESS_RULE)
                                .severity(IssueSeverity.ERROR)
                                .diagnostics(net.sovrinhealth.fhir.model.type.String.of("threads parameter outside required range [1, 64]"))
                                .build());
                        }
                    } else if (PARAM_SIZE.equals(parameter.getName().getValue())) {
                        Integer val = parameter.getValue().as(net.sovrinhealth.fhir.model.type.Integer.class).getValue();
                        if (val != null) {
                            size = val;
                        }

                        if (size < 0) {
                            issues.add(Issue.builder()
                                .code(IssueType.BUSINESS_RULE)
                                .severity(IssueSeverity.ERROR)
                                .diagnostics(net.sovrinhealth.fhir.model.type.String.of("size parameter must be >= 0"))
                                .build());
                        }
                    }
                }
            }

            // Do some busy work
            final long start = System.nanoTime();
            final boolean completed;
            if (size > 0) {
                completed = benchWork(threads, size);            
            } else {
                // size = 0 so we bypass everything, making the call a 
                // fairly lightweight service-level 'ping'
                completed = true;
            }
            double elapsed = (System.nanoTime() - start) / 1e9;

            // must have at least one issue for a valid OperationOutcome resource so we always
            // include this final summary as an issue
            OperationOutcome.Builder result = OperationOutcome.builder();
            final String diag = String.format("Bench operation %s. Took [%6.3f secs]", 
                completed ? "completed" : "didn't complete", elapsed);
            issues.add(Issue.builder()
                .code(IssueType.INFORMATIONAL)
                .severity(IssueSeverity.INFORMATION)
                .diagnostics(net.sovrinhealth.fhir.model.type.String.of(diag))
                .build());
            
            result.issue(issues);

            OperationOutcome operationOutcome = result.build();
            checkOperationOutcome(operationOutcome);
            return FHIROperationUtil.getOutputParameters(operationOutcome);
        } catch (FHIROperationException e) {
            throw e;
        } catch (Throwable t) {
            throw new FHIROperationException("Unexpected error occurred while processing request for operation '"
                    + getName() + "': " + getCausedByMessage(t), t);
        }
    }

    /**
     * Perform some calculations in parallel to consume CPU across the requested number
     * of threads. This should allow clients to perform relative comparisons when
     * deploying to different systems. Not a formal benchmark.
     * @param threads
     * @param size
     */
    private boolean benchWork(int threads, int size) {
        boolean result;
        ExecutorService pool  = Executors.newFixedThreadPool(threads);
        for (int i=0; i<threads; i++) {
            pool.execute(() -> workerLoop(size));
        }
        pool.shutdown();
        try {
            // 60 seconds is a reasonable constant here. The typical transaction timeout
            // is longer, but the threads/size should be adjusted to provide a reasonable
            // response time e.g. 30 seconds for a single call, or something sub-second
            // if multiple bench operation requests are to be submitted in parallel
            result = pool.awaitTermination(60, TimeUnit.SECONDS);
        } catch (InterruptedException x) {
            result = false;
            logger.warning("interrupted waiting for bench worker pool to complete");
        }

        if (!result) {
            // work didn't complete, so force it. Note that this requires the
            // worker loop to listen for thread interruption.
            pool.shutdownNow();
        }
        return result;
    }
    
    /**
     * The work loop performed within one thread. Terminates when the
     * amount of work requested by size is complete, or the thread is
     * interrupted.
     * 
     * @implNote the purpose of this operation is to involve only
     * the CPU so we don't do anything which may involve the database
     * - hence there's no transaction active. That means we can't
     * invoke the FHIRValidator, because it may need to load resources
     * from the database.
     * 
     * @param size
     */
    private void workerLoop(int size) {

        Resource resource = readJsonResource(EXAMPLE_RESOURCE);

        // now do a bunch of work on this resource to burn some CPU. The rough
        // goal is to have one iteration take approximately 1 second on a
        // current (2021-ish) CPU. This is arbitrary and approximate, but makes 
        // the 'size' value a little more intuitive in terms of how much work 
        // is requested for a particular call. Note that if size = 0, we don't
        // start any work and so the request becomes a very lightweight 'ping'
        for (int i=0; i<size * 4; i++) {

            ResourceFingerprintVisitor visitor = new ResourceFingerprintVisitor();
            resource.accept(visitor);

            // Do a rebuild of the resource
            resource = resource.toBuilder().build();

            // Render as JSON, then parse again
            InputOutputByteStream ioStream = new InputOutputByteStream(DATA_BUFFER_INITIAL_SIZE);

            // Serialize and compress the Resource
            try (GZIPOutputStream zipStream = new GZIPOutputStream(ioStream.outputStream())) {
                FHIRGenerator.generator(Format.JSON, false).generate(resource, zipStream);
                zipStream.finish();

                // Now parse the generated resource again
                try (GZIPInputStream inStream = new GZIPInputStream(ioStream.inputStream())) {
                    FHIRParser.parser(Format.JSON).parse(inStream);
                }
            } catch (Exception x) {
                logger.log(Level.WARNING, "failed to process resource", x);
            }
        }
    }

    /**
     * Check the OperationOutcome for any errors
     * @param oo
     * @throws FHIROperationException
     */
    private void checkOperationOutcome(OperationOutcome oo) throws FHIROperationException {
        List<Issue> issues = oo.getIssue();
        for (Issue issue : issues) {
            IssueSeverity severity = issue.getSeverity();
            if (severity != null && (IssueSeverity.ERROR.getValue().equals(severity.getValue())
                    || IssueSeverity.FATAL.getValue().equals(severity.getValue()))) {
                throw new FHIROperationException("The bench operation reported one or more errors").withIssue(issues);
            }
        }
    }

    private String getCausedByMessage(Throwable throwable) {
        return throwable.getClass().getName() + ": " + throwable.getMessage();
    }

    /**
     * Read the resource file packaged with the project
     * @param resourceFile
     * @return
     */
    private Resource readJsonResource(String resourceFile) {
        try (Reader reader = resourceReader(resourceFile)) {
            return FHIRParser.parser(Format.JSON).parse(reader);
        } catch (Exception x) {
            logger.warning("Unable to read packaged resource: " + resourceFile);
            throw new IllegalStateException(x);
        }
    }

    /**
     * Get a reader for the packaged resource file
     * @param resource
     * @return
     * @throws IOException
     */
    private Reader resourceReader(String resource) throws IOException {
        InputStream is;
    
        ClassLoader cl = Thread.currentThread().getContextClassLoader();
        is = cl.getResourceAsStream(resource);
        if (is == null) {
            // Try the class's classloader instead
            is = BenchOperation.class.getResourceAsStream(resource);
        }

        if (is == null) {
            throw new FileNotFoundException("resource not found: " + resource);
        }

        return new InputStreamReader(is, StandardCharsets.UTF_8);
    }
}
